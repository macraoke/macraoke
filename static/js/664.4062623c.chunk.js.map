{"version":3,"file":"static/js/664.4062623c.chunk.js","mappings":"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","sources":["components/SubtitlePlayer/SubtitlePlayer.tsx","../node_modules/parse-srt/src/parse-srt.js"],"sourcesContent":["import parseSRT from 'parse-srt';\nimport React from 'react';\nimport './SubtitlePlayer.module.scss';\n\ninterface SubtitlePlayerProps { }\n\ninterface SubtitlePlayerState {\n  time: number;\n  lyric?: Lyrics;\n}\n\ninterface Lyrics {\n  id: number;\n  start: number;\n  end: number;\n  text: string;\n}\n\nconst UPDATE_INTERVAL = 100;\n\nclass SubtitlePlayer extends React.Component<SubtitlePlayerProps, SubtitlePlayerState> {\n\n  constructor(props: SubtitlePlayerProps) {\n    super(props);\n    this._lyricId = 0;\n    this._Mounted = false;\n    this.state = {\n      time: 0,\n      lyric: undefined\n    };\n  }\n\n  private _interval?: NodeJS.Timer;\n  private _lyrics?: Lyrics[];\n  private _lyricId: number;\n  private _Mounted: boolean;\n\n  componentDidMount() {\n    if (!this._Mounted) {\n      this._Mounted = true;\n      this._loadAndPlay();\n    }\n  }\n\n  componentWillUnmount() {\n    if (!!this._interval) clearInterval(this._interval);\n  }\n\n  render() {\n    return <div>\n      <p>Time: {this.state?.time}</p>\n      <p>Text: {this.state?.lyric?.text}</p>\n    </div>;\n  }\n\n  private async _loadAndPlay() {\n    await this._loadLyrics();\n    this._interval = setInterval(this._beat.bind(this), UPDATE_INTERVAL);\n  }\n\n  private async _loadLyrics() {\n    const response = await fetch('/subtitles/f-s_Vv82yFw.srt');\n    this._lyrics = parseSRT(await response.text());\n  }\n\n  private _beat() {\n    const initTime = this.state.time;\n    this.setState({\n      time: initTime + UPDATE_INTERVAL,\n      lyric: this._findNextLyric()\n    });\n  }\n\n  private _findNextLyric(id = this._lyricId): Lyrics | undefined {\n    if (!this._lyrics || id >= this._lyrics.length)\n      return undefined;\n    const lyric = this._lyrics[id];\n    const start = lyric.start * 1000;\n    const end = lyric.end * 1000;\n    const now = this.state.time;\n    if (now <= end) {\n      if (now < start) // didn't start yet\n        return undefined;\n      this._lyricId = id;\n      return lyric;\n    }\n    return this._findNextLyric(id + 1);\n  }\n\n}\n\nexport default SubtitlePlayer;\n","'use strict'\n\n/**\n * @name parseSRT\n * @desc Parses and converts SRT subtitle data into JSON format. Adapted from the popcorn.js SRT parser plugin.\n * @see http://popcornjs.org/\n * @author Luis Rodrigues (http://www.luisrodriguesweb.com)\n * @version 1.0.0-alpha\n * @license MIT\n */\n\n/**\n * @typedef {JSONSubtitle}\n * @property {Number} id - The subtitle ID number.\n * @property {Number} start - The start timestamp in seconds.\n * @property {Number} end - The end timestamp in seconds.\n * @property {String} text - The subtitle HTML.\n */\n\n/**\n * Convert a HH:MM:SS,MMM or HH:MM:SS.MMM time format into seconds.\n *\n * @private\n * @param {String} time - The time to be converted.\n * @return {Number} - The time converted to seconds.\n */\nfunction toSeconds (time) {\n  const t = time.split(':')\n\n  try {\n    let s = t[2].split(',')\n\n    // Just in case a . is decimal seperator\n    if (s.length === 1) {\n      s = t[2].split('.')\n    }\n\n    return parseFloat(t[0], 10) * 3600 + parseFloat(t[1], 10) * 60 + parseFloat(s[0], 10) + parseFloat(s[1], 10) / 1000\n  } catch (e) {\n    return 0\n  }\n}\n\n/**\n * Get the next non empty line number.\n *\n * @private\n * @param {Array<String>} linesArray - All the lines.\n * @param {Number} position - The current line number.\n * @return {Number} - The number of the next non empty line.\n */\nfunction nextNonEmptyLine (linesArray, position) {\n  let idx = position\n\n  while (!linesArray[idx]) {\n    idx++\n  }\n\n  return idx\n}\n\n/**\n * Get the last non empty line number.\n *\n * @private\n * @param  {Array<String>} linesArray - All the lines.\n * @return {Number} - The number of the last non empty line.\n */\nfunction lastNonEmptyLine (linesArray) {\n  let idx = linesArray.length - 1\n\n  while (idx >= 0 && !linesArray[idx]) {\n    idx--\n  }\n\n  return idx\n}\n\n/**\n * Parses and converts SRT subtitle data into JSON format.\n *\n * @public\n * @param {String} data - The SRT file contents.\n * @return {Array<JSONSubtitle>} - The subtitles in a JSON format.\n *\n * @example\n * var data = `1\n * 00:00:25,712 --> 00:00:30.399\n * This text is <font color=\"red\">RED</font> and has not been {\\pos(142,120)} positioned.\n * This takes \\Nup three \\nentire lines.\n * This contains nested <b>bold, <i>italic, <u>underline</u> and <s>strike-through</s></u></i></b> HTML tags\n * Unclosed but <b>supported tags are left in\n * <ggg>Unsupported</ggg> HTML tags are left in, even if <hhh>not closed.\n * SSA tags with {\\i1} would open and close italicize {\\i0}, but are stripped\n * Multiple {\\pos(142,120)\\b1}SSA tags are stripped`\n *\n * var subtitles = parseSRT(data)\n */\nexport default function parseSRT (data = '') {\n  // declare needed variables and constants\n  const subs = []\n  const lines = data.split(/(?:\\r\\n|\\r|\\n)/gm)\n  let endIdx = lastNonEmptyLine(lines) + 1\n  let idx = 0\n  let time\n  let text\n  let sub\n\n  for (let i = 0; i < endIdx; i++) {\n    sub = {}\n    text = []\n\n    i = nextNonEmptyLine(lines, i)\n    sub.id = parseInt(lines[i++], 10)\n\n    // Split on '-->' delimiter, trimming spaces as well\n    time = lines[i++].split(/[\\t ]*-->[\\t ]*/)\n\n    sub.start = toSeconds(time[0])\n\n    // So as to trim positioning information from end\n    idx = time[1].indexOf(' ')\n    if (idx !== -1) {\n      time[1] = time[1].substr(0, idx)\n    }\n    sub.end = toSeconds(time[1])\n\n    // Build single line of text from multi-line subtitle in file\n    while (i < endIdx && lines[i]) {\n      text.push(lines[i++])\n    }\n\n    // Join into 1 line, SSA-style linebreaks\n    // Strip out other SSA-style tags\n    sub.text = text.join('\\\\N').replace(/\\{(\\\\[\\w]+\\(?([\\w\\d]+,?)+\\)?)+\\}/gi, '')\n\n    // Escape HTML entities\n    sub.text = sub.text.replace(/</g, '&lt;').replace(/>/g, '&gt;')\n\n    // Unescape great than and less than when it makes a valid html tag of a supported style (font, b, u, s, i)\n    // Modified version of regex from Phil Haack's blog: http://haacked.com/archive/2004/10/25/usingregularexpressionstomatchhtml.aspx\n    // Later modified by kev: http://kevin.deldycke.com/2007/03/ultimate-regular-expression-for-html-tag-parsing-with-php/\n    sub.text = sub.text.replace(/&lt;(\\/?(font|b|u|i|s))((\\s+(\\w|\\w[\\w\\-]*\\w)(\\s*=\\s*(?:\".*?\"|'.*?'|[^'\">\\s]+))?)+\\s*|\\s*)(\\/?)&gt;/gi, '<$1$3$7>')\n    sub.text = sub.text.replace(/\\\\N/gi, '<br />')\n\n    subs.push(sub)\n  }\n\n  return subs\n}\n"],"names":["SubtitlePlayer","props","_interval","_lyrics","_lyricId","_Mounted","state","time","lyric","undefined","this","_loadAndPlay","clearInterval","text","_loadLyrics","setInterval","_beat","bind","fetch","response","parseSRT","initTime","setState","_findNextLyric","id","length","start","end","now","React","toSeconds","t","split","s","parseFloat","e","nextNonEmptyLine","linesArray","position","idx","lastNonEmptyLine","subs","lines","endIdx","sub","i","parseInt","indexOf","substr","push","join","replace"],"sourceRoot":""}